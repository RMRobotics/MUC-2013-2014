#pragma config(Sensor, S1,     brSensor,       sensorCOLORFULL)
#pragma config(Sensor, S2,     frSensor,       sensorCOLORFULL)
#pragma config(Sensor, S3,     flSensor,       sensorLightActive)
#pragma config(Sensor, S4,     blSensor,       sensorCOLORFULL)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


// ==================================================
// ==================================================

////////////////////////////////////////////////////////////
//                                                        //
//            RICHARD MONTGOMERY ROBOTICS TEAM            //
//                       8121                             //
//       CODE FOR THE 2014 ION MINI URBAN CHALLENGE       //
// PRIMARY VERSION FOR WASHINGTON DC REGIONAL COMPETITION //
//                                                        //
////////////////////////////////////////////////////////////

// ==================================================
// ==================================================

// IDEAS
// Offset one sensor to try to "keep" line in middle?
// Offset one pair of sensors from the other - use the wider one to find parking spaces?
// Handle points at which there will be a missing side
// Handle points at which there will be a missing stop sign
// Determining stop sign (e.g. when running over stop line in intersection)

// Doing pivot turn: turn outer wheel pair until
// Roundabout: angle toward outside and constantly turn back in - need to handle stop sign
//

// CONSTANTS


// ==================================================
// ==================================================

// FUNCTION DECLARATIONS
void goStraight(string side, bool untilGap); //"both", "left", "right"
void park(string side, int lot);
void unpark(string side); //side to stop on
void turn(int direction, int grade); //handle roundabout?
void drive():
void setMotorValues(int direction, int grade);
int[] getSensorValues(); //returns Black, Blue, Green, Yellow, Red, White, ???
                         //[0] = front left; [1] = front right; [2] = back left; [3] = back right;



// ==================================================
// ==================================================

// MAIN PROGRAM

void setMotorValues(int direction, int grade){
  if(driveDirection==1){
    motor1 = 100;
    motor2 = 100;
  }elseif(driveDirection==2){ //LEFT
    motor1 = -100;
    motor2 = 100;
  }elseif(driveDirection==3){ //RIGHT
    motor1 = 100;
    motor2 = -100;
  }elseif(driveDirection==4){ //REVERSE
    motor1 = -100;
    motor2 = -100;
  }
}

void goStraight(string side, bool untilGap){ //"both", "left", "right"
  string colorRB = sensorVals[3];
  string colorLB = sensorVals[2];
  string colorRF = sensorVals[1];
  string colorLF = sensorVals[0];
  if (side.equals("both")) {
    if(colorLB ==WHITE && colorRB ==WHITE){
      DRIVESTRAIGHT
    }elseif(colorLB==WHITE && colorRB != COLOR){
      colorSensor=1;
      if(colorLF!=COLOR OF colorLB){
        DRIVESTRAIGHT
      }elseif(colorLF==COLOR OF colorLB){
        SHIFT LEFT AND DRIVE STRAIGHT
      }
    }elseif(colorRB==WHITE && colorLB != COLOR){
      colorSensor=2;
      if(colorRF!=COLOR OF colorRB){
        DRIVESTRAIGHT
      }elseif(colorRF==COLOR OF colorRB){
        SHIFT RIGHT AND DRIVE STRAIGHT
      }
    }
    if(colorLB!=COLOR && colorSensor==1){
      SHIFT RIGHT AND DRIVE STRAIGHT
    }elseif{colorRB!=COLOR && colorSensor==2){
      SHIFT LEFT AND DRIVE STRAIGHT
    }
  }else if (side.equals("left")) {
  
  }else {
  }
}

int[] getSensorValues() {
  int sensorVals[4];
  sensorVals[0] = SensorValue[flColor];
  sensorVals[1] = SensorValue[frColor];
  sensorVals[2] = SensorValue[blColor];
  sensorVals[3] = SnesorValue[brColor];
  return sensorVals[];
}

task main()
{
}
